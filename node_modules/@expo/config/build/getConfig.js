"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_file_1 = __importDefault(require("@expo/json-file"));
const jest_message_util_1 = require("jest-message-util");
const path_1 = __importDefault(require("path"));
const Errors_1 = require("./Errors");
const Modules_1 = require("./Modules");
// support all common config types
exports.allowedConfigFileNames = (() => {
    const prefix = 'app';
    return [
        // order is important
        // TODO: Bacon: Slowly rollout support for other config languages: ts, yml, toml
        `${prefix}.config.js`,
        `${prefix}.config.json`,
    ];
})();
function isMissingFileCode(code) {
    return ['ENOENT', 'MODULE_NOT_FOUND', 'ENOTDIR'].includes(code);
}
function reduceExpoObject(config) {
    if (!config)
        return null;
    if (typeof config.expo === 'object') {
        // TODO: We should warn users in the future that if there are more values than "expo", those values outside of "expo" will be omitted in favor of the "expo" object.
        return config.expo;
    }
    return config;
}
function findAndEvalConfig(request) {
    // TODO(Bacon): Support custom config path with `findConfigFile`
    // TODO(Bacon): Should we support `expo` or `app` field with an object in the `package.json` too?
    function testFileName(configFilePath) {
        if (!Modules_1.fileExists(configFilePath))
            return null;
        try {
            return evalConfig(configFilePath, request);
        }
        catch (error) {
            // If the file doesn't exist then we should skip it and continue searching.
            if (!isMissingFileCode(error.code)) {
                throw error;
            }
        }
        return null;
    }
    if (request.configPath) {
        const config = testFileName(request.configPath);
        if (config) {
            return reduceExpoObject(serializeAndEvaluate(config));
        }
        else {
            throw new Errors_1.ConfigError(`Config with custom path ${request.configPath} couldn't be parsed.`, 'INVALID_CONFIG');
        }
    }
    for (const configFileName of exports.allowedConfigFileNames) {
        const configFilePath = path_1.default.resolve(request.projectRoot, configFileName);
        const config = testFileName(configFilePath);
        if (config)
            return reduceExpoObject(serializeAndEvaluate(config));
    }
    return null;
}
exports.findAndEvalConfig = findAndEvalConfig;
// We cannot use async config resolution right now because Next.js doesn't support async configs.
// If they don't add support for async Webpack configs then we may need to pull support for Next.js.
function evalConfig(configFile, request) {
    let result;
    if (configFile.endsWith('.json')) {
        result = json_file_1.default.read(configFile, { json5: true });
    }
    else {
        try {
            require('@babel/register')({
                only: [configFile],
            });
            result = require(configFile);
        }
        catch (error) {
            if (isMissingFileCode(error.code) || !(error instanceof SyntaxError)) {
                throw error;
            }
            const message = jest_message_util_1.formatExecError(error, { rootDir: request.projectRoot, testMatch: [] }, { noStackTrace: true }, undefined, true);
            throw new Errors_1.ConfigError(`\n${message}`, 'INVALID_CONFIG');
        }
        if (result.default != null) {
            result = result.default;
        }
        if (typeof result === 'function') {
            result = result(request);
        }
    }
    if (result instanceof Promise) {
        throw new Errors_1.ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');
    }
    return result;
}
function serializeAndEvaluate(val) {
    if (['undefined', 'string', 'boolean', 'number', 'bigint'].includes(typeof val)) {
        return val;
    }
    else if (typeof val === 'function') {
        // TODO: Bacon: Should we support async methods?
        return val();
    }
    else if (Array.isArray(val)) {
        return val.map(serializeAndEvaluate);
    }
    else if (typeof val === 'object') {
        const output = {};
        for (const property in val) {
            if (val.hasOwnProperty(property)) {
                output[property] = serializeAndEvaluate(val[property]);
            }
        }
        return output;
    }
    // symbol
    throw new Errors_1.ConfigError(`Expo config doesn't support \`Symbols\`: ${val}`, 'INVALID_CONFIG');
}
exports.serializeAndEvaluate = serializeAndEvaluate;
//# sourceMappingURL=getConfig.js.map